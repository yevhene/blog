{"data":{"site":{"siteMetadata":{"title":"React та JavaScript","author":"Yevhen Shemet"}},"markdownRemark":{"id":"5114de52-efe2-596a-a34a-e90e9793da08","html":"<p>Опубліковано на <a href=\"https://dou.ua/lenta/articles/react-fiber/\">DOU</a> 29.09.2017</p>\n<h2>Fiber</h2>\n<p>Це нова архітектура, що покладена в основу React 16. Велика частина коду була переписана з нуля. Основною метою було створення можливості для пріоритизації оновлень контенту. Також переписана система обробки помилок та усунуті деякі старі незручності, наприклад, необхідність обгортати декілька елементів в один кореневий елемент. Існуюче API, на щастя, майже не зачіпили.</p>\n<h2><a href=\"https://present-fiber-demo.herokuapp.com/\">Демо</a></h2>\n<p>Розпочати знайомство краще всього з проблеми, яку має вирішити нова версія. Її добре видно на демо. Демо синтетичне, симулює щось накшталт екрану диспетчерської таксі. На карті міста жовті машини. На машинах чорні числа, що вказують скільки машині ще їхати до точки призначення. Числа змінюються кожної секунди, і під час цієї зміни, анімація підлагує. Лаги з’являються тому, що виконується дві паралельні дії: обробка анімації та оновлення DOM. Анімація працює добре аж до поки не стається масоване оновлення DOM.</p>\n<p>Щоб проблему було краще видно, введена штучна затримка, не забувайте що демо синтетичне. Але проблема цілком реальна: поки переобраховується DOM, анімація не програється, через те що всі ресурси покладено на роботу з DOM. І в рамках старої архітектури React, цю проблему не можна було вирішити аж ніяк. Треба віддати належне розробникам бібліотеки - вони, зіткнувшись з цією проблемою, переписали значну частину коду. Не дивлячись на це, міграція не має викликати великі труднощі.</p>\n<p>Забігаючи наперед, скажу, що якщо натиснути на чекбокс зверху, демо переключиться у режим <em>fiber</em> і перестане гальмувати. (До речі, не залишайте демо надовго на самоті, бо воно казиться).</p>\n<h2>Наразі</h2>\n<p>React, для забезпечення вискої швидкості роботи, виористовує технологію <em>Vitrual DOM</em>: В пам’яті підтримується спрощена копія DOM, де за вузлами закріплені конкретні <em>екземпляри</em> (instance) компонентів, що ними керують. Коли змінюється стан екземпляру, відбувається процес оновлення, що складається з етапів:</p>\n<ul>\n<li>Компоненти опитуються щодо змін;</li>\n<li>DOM в пам’яті перебудовується;</li>\n<li>Обраховується різниця з реальним деревом DOM, та вносяться безпосередні зміни.</li>\n</ul>\n<p>Минулі версії React для оновлення використовували алгоритм, що його заднім числом назвали <em>Stack</em>. І в нього, з часом, виявився значний недолік: він працює простим пошуком в глибину і його робота неперервна. А оскільки в браузері все виконується в одному потоці, то під час оновлення, інші процеси мають зачекати. У випаду високоприорітетних оновлень, наприклад анімаціі, це може стати відчутним клопотом.</p>\n<h2>Новий алгоритм оновлення</h2>\n<p>Архітектура <em>fiber</em> названа на честь алгоритму, що лежить в її основі. Алгоритм полягає у розбитті процесу оновлення на дві фази:</p>\n<ol>\n<li>Фаза <em>узгодження</em> (reconciliation) - коли виконуються переобрахунки компонентів і відбувається оновлення DOM у пам’яті;</li>\n<li>Фаза <em>внеску</em> (commit) - коли виконується безпосереднє оновлення DOM.</li>\n</ol>\n<p>Варто зазначити, що фазу <em>узгодження</em> (reconciliation), можна переривати. <em>fiber</em> за допомогою <a href=\"https://developer.mozilla.org/ru/docs/Web/API/Window/requestIdleCallback\">requestIdleCallback</a>, просить у браузера виділити час, коли той не буде завантажений роботою. При зворотньому виклику, браузер вказує скільки, власне, в нього є вільного часу. Це дає змогу <em>fiber</em>-у планувати частину оновлень на цей проміжок. Якщо браузер не підтримує <code class=\"language-text\">requestIdleCallback</code>, то React робить <em>поліфіл</em> (polyfill).</p>\n<p>Алгоритм <em>fiber</em> у свою чергу названий на честь найменшого об’єкта, що лежить в його основі. За кожним еземпляром (компонента чи елемента) закріплений такий об’єкт, що контролює його стан та зв’язок з іншими компонентами.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token punctuation\">{</span>\n  stateNode\n  <span class=\"token keyword\">return</span>\n  child\n  sibling\n  parent\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<h2>Процес оновлення виглядає наступним чином:</h2>\n<p>У нас є <em>поточне</em> (current) дерево компонентів та елементів, сформоване за допомогою об’єктів <em>fiber</em>. Стрілочки вниз це <code class=\"language-text\">child</code>, вверх <code class=\"language-text\">parent</code>, вправо <code class=\"language-text\">sibling</code>.\n<img src=\"/fiber-0-1032fe53e932ed2803e597e57dab3ca7.svg\" alt=\"current tree\"></p>\n<p>Створюється паралельне <em>робоче</em> (workInProgress) дерево, що частково складається зі старого дерева.\n<img src=\"/fiber-1-a291c99c062e9e61c501e55832a3bd5b.svg\" alt=\"workInProgress tree\"></p>\n<p>Визначаються компоненти, що мають зміни (позначені зірочками).\n<img src=\"/fiber-2-d93165a67c4657c44ccf619e3688b13f.svg\" alt=\"determining which nodes to upgrade\"></p>\n<p>Дерево поступово розгортується, і на його основі відбудовується нове дерево. Там де є оновлення - клонуються елементи і вносяться зміни. Там де оновлень немає - використовуються існуючі елементи.\n<img src=\"/fiber-3-fe933e3e2bee62df87c9cb5cc13da908.svg\" alt=\"cloning DOM nodes\"></p>\n<p>В результаті формується <em>внесок</em> (pending commit). Що, для застосування, очікує вже більшого проміжку часу. Тому що фазу <em>внеску</em> переривати не можна.\n<img src=\"/fiber-4-98cdb8bdaa54d916a5d5d7d777c8094a.svg\" alt=\"effects list\"></p>\n<p>Після того, як відбувається <em>внесок</em> (commit), <em>поточне</em> (current) дерево не знищується. Для економії часу, дерева просто міняються місцями. Це називається <em>подвійна буферизація</em> (double buffering).\n<img src=\"/fiber-5-6dfdc5011b2c8ecea57493c166ce0321.svg\" alt=\"double buffering\"></p>\n<h2>Застосування</h2>\n<p>Для того щоб відчути нові можливості необхідно застосувати режим <em>відкладених оновлень</em> <code class=\"language-text\">ReactDOM.unstable_deferredUpdates</code>. (Всі експериментальні можливості спочатку поставляються з префіксом <code class=\"language-text\">unstable_</code>).</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">tick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">unstable_deferredUpdates</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>prevState<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      tick<span class=\"token punctuation\">:</span> prevState<span class=\"token punctuation\">.</span>tick <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>Оновлення що відбуваються в рамках <code class=\"language-text\">deferredUpdates</code> відбуваються паралельно.\nЗверніть увагу:</p>\n<ul>\n<li>Необхідно застосовувати <code class=\"language-text\">setState</code> зі <em>зворотним викликом</em> (callback), <code class=\"language-text\">setState</code> з об’єктом стає <em>застарілим</em> (deprecated);</li>\n<li>Якщно новий стан буде залежати від поточного стану, то необхідно використовувати параметр зворотнього виклику <code class=\"language-text\">prevState</code>, замість <code class=\"language-text\">this.state</code>. Тому що він може бути викликаний декілька разів.</li>\n</ul>\n<h3>Порівняння</h3>\n<p>Жовтим позначені - оновлення, фіолетовим - анімації, червоним - лаги.</p>\n<p>Stack:\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/perf-not-fiber-c6fbb945a3371f8db1675818db95be4b-edf7e.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 11.608961303462321%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsSAAALEgHS3X78AAAAYElEQVQI1zXJSwqEMAwAUO9/JJk5isg40tQ0ST9ITUTBuujy8QYX/2woFta0OPCm1S49b5MiwZM23i+5EUitMzO6MCz0w7r5HfDwCT6UJlbhitEkw5dy5xmLG7nMfbnxAcg+b5VeNugKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"stack\"\n        title=\"\"\n        src=\"/static/perf-not-fiber-c6fbb945a3371f8db1675818db95be4b-fb8a0.png\"\n        srcset=\"/static/perf-not-fiber-c6fbb945a3371f8db1675818db95be4b-1a291.png 148w,\n/static/perf-not-fiber-c6fbb945a3371f8db1675818db95be4b-2bc4a.png 295w,\n/static/perf-not-fiber-c6fbb945a3371f8db1675818db95be4b-fb8a0.png 590w,\n/static/perf-not-fiber-c6fbb945a3371f8db1675818db95be4b-526de.png 885w,\n/static/perf-not-fiber-c6fbb945a3371f8db1675818db95be4b-edf7e.png 982w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Fiber:\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/perf-fiber-db8234e7294a275a601a78e4b9df0601-8f3e6.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; ; max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 11.902231668437834%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcElEQVQI1xXHyxGDIBQAQPvvJWkjF0tIBtSg7wPCKHmAyhjd2zY9K3+EUGVe/AfeNoPbfKiRAqLFvEupZT+PeQ1wN5W6XfVx0aZrlO0GbpV6cJpARhNhwJfWTxJyhUmQZaLYW/naBJyQfyOtV43L+AeT427o5bZonwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"fiber\"\n        title=\"\"\n        src=\"/static/perf-fiber-db8234e7294a275a601a78e4b9df0601-fb8a0.png\"\n        srcset=\"/static/perf-fiber-db8234e7294a275a601a78e4b9df0601-1a291.png 148w,\n/static/perf-fiber-db8234e7294a275a601a78e4b9df0601-2bc4a.png 295w,\n/static/perf-fiber-db8234e7294a275a601a78e4b9df0601-fb8a0.png 590w,\n/static/perf-fiber-db8234e7294a275a601a78e4b9df0601-526de.png 885w,\n/static/perf-fiber-db8234e7294a275a601a78e4b9df0601-8f3e6.png 941w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Як бачинте обробка CSS анімацій не зупиняється, навіть при восокій завантаженості оновленнями DOM.</p>\n<h2>Також</h2>\n<p>Разом з новою архітектурою, при переписуванні React, були виправлені деякі, невеликі архітектурні помилки.</p>\n<h3>Фрагменти (Fragments)</h3>\n<p>Відтепер, якщо компонент повертає набір елементів, його не обов’язково обгортати в один корінний елемент. Ви можете повертати масив елементів, що дуже зручно в місцях, де неможливо просто обгорнути елементи в <code class=\"language-text\">&lt;div&gt;</code>. Наприклад, в роботі з таблицями і списками, якщо компонент має повернути декілька рядків або елементів списку. Також тепер можна повертати стрічки.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">TableHeader</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token operator\">&lt;</span>tr<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>th colspan<span class=\"token operator\">=</span><span class=\"token string\">\"2\"</span><span class=\"token operator\">></span>Автомобіль<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>th<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>th colspan<span class=\"token operator\">=</span><span class=\"token string\">\"2\"</span><span class=\"token operator\">></span>Водій<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>th<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>tr<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">&lt;</span>tr<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>th<span class=\"token operator\">></span>Номер<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>th<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>th<span class=\"token operator\">></span>Марка<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>th<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>th<span class=\"token operator\">></span>Позивний<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>th<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span>th<span class=\"token operator\">></span>Телефон<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>th<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>tr<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<h3>Кордони помилок (Error boundaries)</h3>\n<p>Запроваджена нова система обробки помилок. Тепер, якщо в компоненті виникає помилка, можна застосувати метод життєвого циклу <code class=\"language-text\">componentDidCatch</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Map</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> hasError<span class=\"token punctuation\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">componentDidCatch</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">,</span> info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> hasError<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>hasError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>На жаль<span class=\"token punctuation\">,</span> сталась прикра помилка<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>MapContent <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<h3>Портали (Portals)</h3>\n<p>Іноді виникає необхідність створити елемент не в рамках поточної ієрархії, а приєднати, наприклад, як у випадку з модальними вікнами, до <code class=\"language-text\">&lt;body&gt;</code>. На допомогу приходять портали.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">createPortal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>Modal <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> domElement<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<h3>Атрибути (Attributes)</h3>\n<p>React 16 дозволяє вам використовувати власні атрибути.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>div hello<span class=\"token operator\">=</span><span class=\"token string\">\"world\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre>\n      </div>\n<p>Будьте обережні. Це означає, що фільтрація атрибутів більше не виконується.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token operator\">&lt;</span>div myData<span class=\"token operator\">=</span><span class=\"token string\">\"[Object object]\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre>\n      </div>\n<p>Тим не менш, атрибути що мають канонічне ім’я все одно валідуються. І вас буде попереджено, якщо ви використовуєте неправильне ім’я атрибута.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Warning: Invalid DOM property `tabindex`. Did you mean `tabIndex`?</span>\n<span class=\"token operator\">&lt;</span>div tabindex<span class=\"token operator\">=</span><span class=\"token string\">\"-1\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span></code></pre>\n      </div>\n<h2>Майбутнє</h2>\n<p>Потенціал нової архітектури реалізовано не повністю. І у розробників є багато планів на майбутнє, що стали реальними завдяки <em>fiber</em>.</p>\n<h2>Пріоритизація</h2>\n<p>Оновлення всередині вже пріоритизуються, але цей процесс ще далекий від ідеалу, крім того, очікується більше контролю над цим процесом. Пріоритети:</p>\n<ul>\n<li>Synchronous - Синхронний, виконується зараз;</li>\n<li>Task - Задача, до наступного <em>тіку</em> (tick);</li>\n<li>Animation - Анімація, до наступного <em>кадру</em> (frame);</li>\n<li>High - Високий;</li>\n<li>Low - Низький;</li>\n<li>Offscreen/Hidden - схованний або поза межами екрану.</li>\n</ul>\n<h3>Превізуалізація (pre-rendering)</h3>\n<p>Оскільки візуалізація розбита на дві фази, то можна чітко визначити коли все необхідне завантажене, обраховане і готове до відображення. Це відкриває шлях, в майбутньому, до потокового завантаження превізуалізованих на сервері компонентів. Також це має спростити етап завантаження великих аплікацій.</p>\n<h3>Абстракція</h3>\n<p>Мабуть, ви знаєте, що React наразі працює на великій кількості платформ. Наприклад:</p>\n<ul>\n<li>Браузер: <code class=\"language-text\">react-dom</code></li>\n<li>Мобільні: <code class=\"language-text\">react-native</code></li>\n<li>Термінал: <code class=\"language-text\">react-blessed</code></li>\n<li>Віртуальна реальність: <code class=\"language-text\">aframe-react</code></li>\n<li>Arduino: <code class=\"language-text\">react-hardware</code></li>\n</ul>\n<p>Команда React активно працює над тим, щоб зробити React незалежним від оточення. З версії <code class=\"language-text\">v0.14</code> ReactDOM був виділений в окремий пакет. З версії <code class=\"language-text\">v0.16</code> розробники рапортують, що React став (майже :)) повністю незалежний від браузера.</p>\n<h2>Проблеми</h2>\n<p>Коли запускається оновлення, а минуле ще обраховане не до кінця - то старе оновлення припиняється і його проміжний результат відкидається. Якщо таке стається регулярно, виникає ситуація коли дані на сторінці оновлюються нерегулярно або зовсім не оновлюються. Така ситуація називається <em>голодування</em> <code class=\"language-text\">starvation</code>.</p>\n<h2>Наслідки</h2>\n<h3>Життєвий цикл компоненту</h3>\n<p>Будьте уважні та обережні, якщо ви використовуєте відкладені оновлення. Деякі методи життєвого циклу під час одного оновлення можуть викликатись двічі або більше разів. Пов’язано це з тим, що оновлення може бути відкладене, через більш нагальні оновлення, а потім переобраховане.\nЦе методи фази <em>узгодження</em> (reconciliation):</p>\n<ul>\n<li><code class=\"language-text\">componentWillMount</code></li>\n<li><code class=\"language-text\">componentWillReceiveProps</code></li>\n<li><code class=\"language-text\">shouldComponentUpdate</code></li>\n<li><code class=\"language-text\">componentWillUpdate</code></li>\n</ul>\n<p>Методи фази <em>внеску</em> (commit), викликаються тільки один раз:</p>\n<ul>\n<li><code class=\"language-text\">componentDidMount</code></li>\n<li><code class=\"language-text\">componentDidUpdate</code></li>\n<li><code class=\"language-text\">componentWillUnmount</code></li>\n</ul>\n<h3>Помилки</h3>\n<p>Відтепер, з введенням кордонів помилок, React, у випадку помилки, не намагається продовжувати роботу. Це покладається на ваші плечі. Якщо є необроблена помилка, що доходить до верхнього рівня, дерево компонентів повністю перемонтується.</p>\n<h3>Атрибути</h3>\n<p>React більше не видаляє незнайомі атрибути і вам бажано (але не необхідно) це робити самим.</p>\n<h3>setState</h3>\n<p>Виклик виду <code class=\"language-text\">setState({ key: value })</code> вважається <em>застарілим</em> (deprecated). Використовуйте <code class=\"language-text\">setState</code> зі <em>зворотним викликом</em> (callback).</p>\n<h2>Матеріали та ресурси</h2>\n<h3>Посилання</h3>\n<ul>\n<li>Код презентації та демо: <a href=\"http://github.com/yevhene/present-fiber\">http://github.com/yevhene/present-fiber</a></li>\n</ul>\n<h3>Ресурси</h3>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=QW5TE4vrklU\">Keynote - Andrew Clark aka @acdlite at @ReactEurope 2017</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=U9zFfIww3Go\">A tiny Fiber renderer - Dustan Kasten, React London 2017</a></li>\n</ul>","frontmatter":{"title":"React 16 (fiber і далі)","date":"September 29, 2017"}}},"pageContext":{"jsonName":"react-fiber-d24","internalComponentName":"ComponentReactFiber","path":"/react-fiber/","component":"/home/yevhene/work/blog/src/templates/blog-post.js","componentChunkName":"component---src-templates-blog-post-js","context":{"slug":"/react-fiber/","previous":null,"next":null},"updatedAt":1530176489952,"pluginCreator___NODE":"Plugin default-site-plugin","pluginCreatorId":"Plugin default-site-plugin","componentPath":"/home/yevhene/work/blog/src/templates/blog-post.js","slug":"/react-fiber/","previous":null,"next":null}}